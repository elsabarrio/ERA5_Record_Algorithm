---
title: "2-Local_models"
format: html
editor: visual
---

## Create local models

This code uses the local data frames obtained from the previous script to create the local models, one for each station. Four models are created for each station, and the one with the lowes AIC value is kept. These models are: a model with only the geopotential variables as predictors, a model with the geopotential variables and a lag term of them, a model with the geopotential variables and a second order polynomial term, and a model with the geopotential variables, the lag terms, and the second order polynomials.

## Set records and refine station names

This code cell sets the records using maximum temperature temperatures and refines some of the names from the station data frame.

```{r message = FALSE, warning = FALSE}

# Clear workspace
rm(list = ls())

# Set working directory
wd <- "C:/Users/elsac/Documents/Excess.records"

# Set data directory
data_dir <- file.path(wd,"Data")
if(!dir.exists(data_dir)) stop("data_dir not found")

# Read list of observatories of interest. Based on previous work.
stations <- read.csv(file.path(data_dir,"geo_peninsula_zones.csv"))

# Do not consider (for now) more than one station from Madrid
stations$STANAME[which(is.na(stations$Zona))]
idx <- which(!is.na(stations$Zona))
stations <- stations[idx,]

# Modify Barcelona-Airport label
stations$STANAME[10] <- "FABRA OBSERVATORY                       "
stations$STANAME[25] <- "BCN/AEROPUERTO                          "

# Create station names abbreviations
stations$abb <- substr(stations$STANAME,1,6)

```

## Create local models and save them

In the code cell below we create the four local models for each station and save the best one.

```{r}

library(MASS)
library(pROC)
# Find directory with the local data frames
df_dir <- file.path(data_dir,"local.dataframes/")
stations.dfs <- list.files(df_dir)

# Define output directory to save the models
outdir <- file.path(wd,"Results/local.models")

# Create matrix to save AUC values
AUC.mat <- matrix(nrow = 2, ncol = length(stations.dfs))
AUC.idx <- 0

# Start loop to construct the local models
if(!dir.exists(outdir)){
  
  # Create output directory to save the models
  dir.create(outdir, recursive = T)
  
  for (station.df in stations.dfs){
  
  # Read data frames
  bin_df <- read.csv(file.path(df_dir, station.df))
  
  # Reorder the columns to have the closer grid variables first and the further grid
  # variables after.
  plot_aux_df <- bin_df[,c(1:7, 12:15, 20:23, 8:11, 16:19, 24:29)]
  
  # Get the station ID and the name from the file names
  staid <- gsub("\\.df.csv$", "", station.df)
  sta_name <- stations$abb[stations$STAID==staid]
  
  # Determine whether the latitude and longitude correspond to North or South, East or West
  if (stations[grep(sta_name, stations$abb),]$LAT >=0.5){
    lat <- paste0(round(stations[grep(sta_name, stations$abb),]$LAT,0),"N")
  }else{lat <- paste0(abs(round(stations[grep(sta_name, stations$abb),]$LAT,0)),"N")}
  
  if (stations[grep(sta_name, stations$abb),]$LON >=0.5){
    lon <- paste0(round(stations[grep(sta_name, stations$abb),]$LON,0),"E")
  }else{lon <- paste0(abs(round(stations[grep(sta_name, stations$abb),]$LON,0)),"W")}
  
  # Find the closest points to the stations being considered
  closest.point.id <- paste0(lat,".",lon)
  selected_columns <- grep(closest.point.id, colnames(plot_aux_df), value = TRUE)
  other_columns <- names(plot_aux_df)[c(1:3, 16:29)]
  
  # Keep only one of the closer points
  plot_df <- plot_aux_df[,c(selected_columns,other_columns)]
  
  # Now add lag variables for each of the geopotential variables
  aux_df <- plot_df[,grep("g[.]",names(plot_df))]
  for (i in 1:ncol(aux_df)){
    col_name <- paste0(names(aux_df)[i], ".lag1")
    plot_df[[col_name]] <- dplyr::lag(aux_df[,i], 1, 0)
  }
  
  global.df <- plot_df
  
  # Add second lag term
  global.df$Ix.lag2 <- dplyr::lag(global.df$Ix, 2, 0)
  
  # Geopotential model formula
  gvars <- names(plot_df)[grep("g[.]",names(plot_df[,1:18]))]
  frm2 <- as.formula(paste0("Ix~",capture.output(cat(gvars, sep = "+"))))
  
  # Geopotential model with lag variables formula
  gvars_lag1 <- names(plot_df)[grep("g[.]",names(plot_df))]
  frm3 <- as.formula(paste0("Ix~",capture.output(cat(gvars_lag1, sep = "+"))))
  
  # Geopotential model with second order polynomial terms formula
  gvars_poly <- sapply(gvars, function(name) paste0("poly(", name,",2)"))
  frm4 <- as.formula(paste0("Ix~",capture.output(cat(gvars_poly, sep = "+"))))
  
  # Geopotential model with second order polynomial and lag terms formula
  gvars_poly_lag <- c(gvars_lag1[grepl("lag1",gvars_lag1)],gvars_poly)
  frm5 <- as.formula(paste0("Ix~",capture.output(cat(gvars_poly_lag, sep = "+"))))
  
  # Set training set
  idx.train = which(global.df$t <= 51)
  
  # Compute a glm for all the models
  fit2 <- glm(formula = frm2, data = global.df[idx.train,], family = binomial(link = "logit"))
  fit3 <- glm(formula = frm3, data = global.df[idx.train,], family = binomial(link = "logit"))
  fit4 <- glm(formula = frm4, data = global.df[idx.train,], family = binomial(link = "logit"))
  fit5 <- glm(formula = frm5, data = global.df[idx.train,], family = binomial(link = "logit"))
  
  # Compute a stepAIC to each of the models
  
  if(!is.element("MASS", row.names(installed.packages()))) install.packages("MASS")
  library(MASS)

  fit2_step <- stepAIC(object = fit2, direction = "both", trace = FALSE)
  fit3_step <- stepAIC(object = fit3, direction = "both", trace = FALSE)
  fit4_step <-stepAIC(object = fit4, direction = "both", trace = FALSE)
  fit5_step <-stepAIC(object = fit5, direction = "both", trace = FALSE)
  
  # List of fitted models
  fitted_models <- list(fit2_step,fit3_step,fit4_step,fit5_step)
  
  # Compute AIC for each model
  AIC_values <- sapply(fitted_models, AIC)
  
  # Identify the index of the model with the lowest AIC
  index_lowest_AIC <- which.min(AIC_values)
  
  # Save the fitted model with the lowest AIC
  best_model <- fitted_models[[index_lowest_AIC]]
  
  # Calculate the AUC value
  df.test <- global.df[-idx.train,]
predict.test <- predict(best_model,newdata = df.test,type = "response")
roc.aux <- roc(df.test$Ix, predict.test, print.auc = TRUE)
print(auc(roc.aux))

# Save AUC values in matrix
AUC.idx <- AUC.idx+1
AUC.mat[1,AUC.idx] <- sta_name
AUC.mat[2,AUC.idx] <- auc(roc.aux)

# Save best model
  saveRDS(best_model, file = file.path(outdir,paste0(staid,".rds")))

  }
  
  # Save AUC matrix
    write.csv2(AUC.mat, file = file.path(wd,"Results/local.AUC.csv"))
}


```
